window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "sdim", "modulename": "sdim", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.circuit", "modulename": "sdim.circuit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.circuit.CircuitInstruction", "modulename": "sdim.circuit", "qualname": "CircuitInstruction", "kind": "class", "doc": "<p>Represents a single instruction in a quantum circuit.</p>\n\n<p>This class encapsulates the details of a quantum gate operation,\nincluding the gate type, target qudit(s), and associated metadata.</p>\n\n<p>Attributes:\n    gate_data (GateData): Contains information about available gates.\n    gate_name (str): The name of the gate.\n    qudit_index (int): The index of the primary qudit the gate acts on.\n    target_index (int, optional): The index of the target qudit for two-qudit gates.\n    gate_id (int): The unique identifier for the gate.\n    name (str): The canonical name of the gate.</p>\n\n<p>Raises:\n    ValueError: If the specified gate is not found in gate_data.</p>\n"}, {"fullname": "sdim.circuit.CircuitInstruction.__init__", "modulename": "sdim.circuit", "qualname": "CircuitInstruction.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gate_data</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">gatedata</span><span class=\"o\">.</span><span class=\"n\">GateData</span>,</span><span class=\"param\">\t<span class=\"n\">gate_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">target_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gate_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "sdim.circuit.CircuitInstruction.gate_data", "modulename": "sdim.circuit", "qualname": "CircuitInstruction.gate_data", "kind": "variable", "doc": "<p></p>\n", "annotation": ": sdim.gatedata.GateData"}, {"fullname": "sdim.circuit.CircuitInstruction.gate_name", "modulename": "sdim.circuit", "qualname": "CircuitInstruction.gate_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "sdim.circuit.CircuitInstruction.qudit_index", "modulename": "sdim.circuit", "qualname": "CircuitInstruction.qudit_index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "sdim.circuit.CircuitInstruction.target_index", "modulename": "sdim.circuit", "qualname": "CircuitInstruction.target_index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "sdim.circuit.CircuitInstruction.gate_id", "modulename": "sdim.circuit", "qualname": "CircuitInstruction.gate_id", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "None"}, {"fullname": "sdim.circuit.CircuitInstruction.name", "modulename": "sdim.circuit", "qualname": "CircuitInstruction.name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "None"}, {"fullname": "sdim.circuit.Circuit", "modulename": "sdim.circuit", "qualname": "Circuit", "kind": "class", "doc": "<p>Represents a quantum circuit.</p>\n\n<p>This class encapsulates the structure and operations of a quantum circuit,\nincluding the number of qudits, their dimension, and the sequence of gate operations.</p>\n\n<p>Attributes:\n    num_qudits (int): The number of qudits in the circuit.\n    dimension (int): The dimension of each qudit (default is 2 for qubits).\n    operations (list): A list of CircuitInstruction objects representing the circuit operations.\n    gate_data (GateData): Contains information about available gates.</p>\n\n<p>Raises:\n    ValueError: If num_qudits is less than 1 or dimension is less than 2.</p>\n"}, {"fullname": "sdim.circuit.Circuit.__init__", "modulename": "sdim.circuit", "qualname": "Circuit.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_qudits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dimension</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">operations</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gate_data</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">gatedata</span><span class=\"o\">.</span><span class=\"n\">GateData</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "sdim.circuit.Circuit.num_qudits", "modulename": "sdim.circuit", "qualname": "Circuit.num_qudits", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "sdim.circuit.Circuit.dimension", "modulename": "sdim.circuit", "qualname": "Circuit.dimension", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "2"}, {"fullname": "sdim.circuit.Circuit.operations", "modulename": "sdim.circuit", "qualname": "Circuit.operations", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list", "default_value": "None"}, {"fullname": "sdim.circuit.Circuit.gate_data", "modulename": "sdim.circuit", "qualname": "Circuit.gate_data", "kind": "variable", "doc": "<p></p>\n", "annotation": ": sdim.gatedata.GateData", "default_value": "None"}, {"fullname": "sdim.circuit.Circuit.add_gate", "modulename": "sdim.circuit", "qualname": "Circuit.add_gate", "kind": "function", "doc": "<p>Adds gate operation(s) to the circuit.</p>\n\n<p>Args:\n    gate_name (str): The name of the gate to add.\n    qudit_index (int or List[int]): The index or indices of the primary qudit(s) the gate acts on.\n    target_index (int, List[int], or None, optional): The index or indices of the target qudit(s) for two-qudit gates.</p>\n\n<p>Returns:\n    Circuit: The current Circuit object with the added operation(s).</p>\n\n<p>Raises:\n    ValueError: If the lengths of qudit_index and target_index lists don't match when both are provided as lists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">gate_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">target_index</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.circuit.Circuit.print_gateData", "modulename": "sdim.circuit", "qualname": "Circuit.print_gateData", "kind": "function", "doc": "<p>Prints the gate data associated with this circuit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.circuit.Circuit.from_operation_list", "modulename": "sdim.circuit", "qualname": "Circuit.from_operation_list", "kind": "function", "doc": "<p>Creates a Circuit object from a list of operations.</p>\n\n<p>Args:\n    operation_list (list): A list of operations, either as tuples or CircuitInstructions.\n    num_qudits (int): The number of qudits in the circuit.\n    dimension (int): The dimension of each qudit.</p>\n\n<p>Returns:\n    Circuit: A new Circuit object with the specified operations.</p>\n\n<p>Raises:\n    ValueError: If an unsupported operation type is encountered.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">operation_list</span>, </span><span class=\"param\"><span class=\"n\">num_qudits</span>, </span><span class=\"param\"><span class=\"n\">dimension</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.circuit_io", "modulename": "sdim.circuit_io", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.circuit_io.read_circuit", "modulename": "sdim.circuit_io", "qualname": "read_circuit", "kind": "function", "doc": "<p>Reads a circuit from a file and creates a Circuit object.</p>\n\n<p>Args:\n    filename (str): The name of the file containing the circuit description.</p>\n\n<p>Returns:\n    Circuit: A Circuit object representing the circuit described in the file.</p>\n\n<p>Raises:\n    ValueError: If an unexpected number of arguments is found for a gate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.circuit_io.write_circuit", "modulename": "sdim.circuit_io", "qualname": "write_circuit", "kind": "function", "doc": "<p>Writes a Circuit object to a file in the .chp format.</p>\n\n<p>Args:\n    circuit (Circuit): The Circuit object to write.\n    output_file (str): The name of the output file. Defaults to \"random_circuit.chp\".\n    comment (str): An optional comment to include at the beginning of the file.</p>\n\n<p>Returns:\n    str: The path to the written file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">circuit</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">Circuit</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;random_circuit.chp&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.circuit_io.circuit_to_cirq_circuit", "modulename": "sdim.circuit_io", "qualname": "circuit_to_cirq_circuit", "kind": "function", "doc": "<p>Converts a Circuit object to a Cirq Circuit object.</p>\n\n<p>Args:\n    circuit (Circuit): The Circuit object to convert.\n    measurement (bool): Whether to include measurement gates. Defaults to False.\n    print_circuit (bool): Whether to print the Cirq circuit. Defaults to False.</p>\n\n<p>Returns:\n    cirq.Circuit: The equivalent Cirq Circuit object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">circuit</span>, </span><span class=\"param\"><span class=\"n\">measurement</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">print_circuit</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.circuit_io.cirq_statevector_from_circuit", "modulename": "sdim.circuit_io", "qualname": "cirq_statevector_from_circuit", "kind": "function", "doc": "<p>Simulates a Circuit object using Cirq and returns the final state vector.</p>\n\n<p>Args:\n    circuit (Circuit): The Circuit object to simulate.\n    print_circuit (bool): Whether to print the Cirq circuit. Defaults to False.</p>\n\n<p>Returns:\n    np.ndarray: The final state vector given by the Cirq simulator.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">circuit</span>, </span><span class=\"param\"><span class=\"n\">print_circuit</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine", "modulename": "sdim.diophantine", "kind": "module", "doc": "<p>Diophantine is a python package for solving systems of diophantine equations \n(see https://en.wikipedia.org/wiki/Diophantine_equation). It is based on \nPHP code by Keith Matthews (webmaster@number-theory.org) that implements the \nalgorithm described in the included 'algorithm.pdf' (see\n<a href=\"http://www.numbertheory.org/lll.html\">http://www.numbertheory.org/lll.html</a> for a list of associated publications).</p>\n\n<p>There are two branches of this code in the GitHub repository\n(see https://github.com/tclose/Diophantine.git), 'master', which uses the\nsympy library and therefore uses arbitrarily long integer representations, and\n'numpy', which uses the numpy library, which is faster but can suffer from\ninteger overflow errors despite using int64 representations.</p>\n\n<p>Diophantine is released under the MIT Licence (see Licence for details)</p>\n\n<p>Author: Thomas G. Close (tom.g.close@gmail.com)</p>\n"}, {"fullname": "sdim.diophantine.print_count", "modulename": "sdim.diophantine", "qualname": "print_count", "kind": "variable", "doc": "<p></p>\n", "default_value": "0"}, {"fullname": "sdim.diophantine.verbose_solve", "modulename": "sdim.diophantine", "qualname": "verbose_solve", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "sdim.diophantine.verbose_hnf", "modulename": "sdim.diophantine", "qualname": "verbose_hnf", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "sdim.diophantine.verbose_chol", "modulename": "sdim.diophantine", "qualname": "verbose_chol", "kind": "variable", "doc": "<p></p>\n", "default_value": "False"}, {"fullname": "sdim.diophantine.solve", "modulename": "sdim.diophantine", "qualname": "solve", "kind": "function", "doc": "<p>Finds small solutions to systems of diophantine equations, A x = b, where A\nis a M x N matrix of coefficents, b is a M x 1 vector and x is the\nN x 1 solution vector, e.g. </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">numpy</span> <span class=\"kn\">import</span> <span class=\"n\">array</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">diophantine</span> <span class=\"kn\">import</span> <span class=\"n\">solve</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span>\n<span class=\"go\">                [0, 1, 1, 1], [-1, 2, 0,1], [-1, -2, 1, 0]]).T</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"go\">[array([</span>\n<span class=\"go\">[-1],</span>\n<span class=\"go\">[ 1],</span>\n<span class=\"go\">[ 0],</span>\n<span class=\"go\">[ 0],</span>\n<span class=\"go\">[-1],</span>\n<span class=\"go\">[-1],</span>\n<span class=\"go\">[-1]])]</span>\n</code></pre>\n</div>\n\n<p>The returned solution vector will tend to be one with the smallest norms.\nIf multiple solutions with the same norm are found they will all be\nreturned. If there are no solutions the empty list will be returned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.lllhermite", "modulename": "sdim.diophantine", "qualname": "lllhermite", "kind": "function", "doc": "<p>Input: integer mxn matrix A, nonzero, at least two rows+\nOutput: small unimodular matrix B and HNF(A), such that BA=HNF(A)+\nThe Havas, Majewski, Matthews LLL method is used+\nWe usually take alpha=m1/n1, with (m1,n1)=(1,1) to get best results+</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">G</span>, </span><span class=\"param\"><span class=\"n\">m1</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">n1</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.initialise_working_matrices", "modulename": "sdim.diophantine", "qualname": "initialise_working_matrices", "kind": "function", "doc": "<p>G is a nonzero matrix with at least two rows.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">G</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.first_nonzero_is_negative", "modulename": "sdim.diophantine", "qualname": "first_nonzero_is_negative", "kind": "function", "doc": "<p>returns 0 if the first nonzero column j of A contains more than one nonzero\nentry, or contains only one nonzero entry and which is positive+ returns 1\nif the first nonzero column j of A contains only one nonzero entry, which\nis negative+ This assumes A is a nonzero matrix with at least two rows+</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.reduce_matrix", "modulename": "sdim.diophantine", "qualname": "reduce_matrix", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">L</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">D</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.minus", "modulename": "sdim.diophantine", "qualname": "minus", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">L</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.swap_rows", "modulename": "sdim.diophantine", "qualname": "swap_rows", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">L</span>, </span><span class=\"param\"><span class=\"n\">D</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.get_solutions", "modulename": "sdim.diophantine", "qualname": "get_solutions", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.cholesky", "modulename": "sdim.diophantine", "qualname": "cholesky", "kind": "function", "doc": "<h1 id=\"a-is-positive-definite-mxm\">A is positive definite mxm</h1>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.gram", "modulename": "sdim.diophantine", "qualname": "gram", "kind": "function", "doc": "<p>Need to check for row and column operations</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.introot", "modulename": "sdim.diophantine", "qualname": "introot", "kind": "function", "doc": "<p>With Z=a/b, U=c/d, returns [numpy.sqrt(a/b)+c/d]. First ANSWER =\n[numpy.sqrt(Z)] + [U]. One then tests if Z &lt; ([numpy.sqrt(Z)] + 1 -U)^2. If\nthis does not hold, ANSWER += 1+ For use in fincke_pohst()+</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.egcd", "modulename": "sdim.diophantine", "qualname": "egcd", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.lnearint", "modulename": "sdim.diophantine", "qualname": "lnearint", "kind": "function", "doc": "<p>left nearest integer\nreturns y+1/2 if a/b=y+1/2, y integral+</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.robust_arithmetic", "modulename": "sdim.diophantine", "qualname": "robust_arithmetic", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">operation</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.ratior", "modulename": "sdim.diophantine", "qualname": "ratior", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.multr", "modulename": "sdim.diophantine", "qualname": "multr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.subr", "modulename": "sdim.diophantine", "qualname": "subr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.addr", "modulename": "sdim.diophantine", "qualname": "addr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.safe_gcd", "modulename": "sdim.diophantine", "qualname": "safe_gcd", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.comparer", "modulename": "sdim.diophantine", "qualname": "comparer", "kind": "function", "doc": "<p>Compares a/b with c/d robustly, handling large numbers and potential overflows.\nAssumes b>0 and d>0.\nReturns -1 if a/b &lt; c/d, 0 if a/b == c/d, and 1 if a/b &gt; c/d.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.lcasvector", "modulename": "sdim.diophantine", "qualname": "lcasvector", "kind": "function", "doc": "<p>lcv[j]=X[1]A[1][j]=...+X[m]A[m][j], 1 &lt;= j &lt;= n+</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.diophantine.print_all", "modulename": "sdim.diophantine", "qualname": "print_all", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">L</span>, </span><span class=\"param\"><span class=\"n\">D</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata", "modulename": "sdim.gatedata", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.gatedata.Gate", "modulename": "sdim.gatedata", "qualname": "Gate", "kind": "class", "doc": "<p>Represents a quantum gate.</p>\n\n<p>Attributes:\n    name (str): The name of the gate.\n    arg_count (int): The number of arguments (qubits) the gate operates on.\n    gate_id (int): A unique identifier for the gate.</p>\n"}, {"fullname": "sdim.gatedata.Gate.__init__", "modulename": "sdim.gatedata", "qualname": "Gate.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">arg_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">gate_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "sdim.gatedata.Gate.name", "modulename": "sdim.gatedata", "qualname": "Gate.name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "sdim.gatedata.Gate.arg_count", "modulename": "sdim.gatedata", "qualname": "Gate.arg_count", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "sdim.gatedata.Gate.gate_id", "modulename": "sdim.gatedata", "qualname": "Gate.gate_id", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "sdim.gatedata.GateData", "modulename": "sdim.gatedata", "qualname": "GateData", "kind": "class", "doc": "<p>Manages a collection of quantum gates and their aliases.</p>\n\n<p>This class handles the creation, storage, and retrieval of quantum gates\nand their associated data for a provided dimension.</p>\n\n<p>Attributes:\n    gateMap (dict): A dictionary mapping gate names to Gate objects.\n    aliasMap (dict): A dictionary mapping gate aliases to their primary names.\n    num_gates (int): The total number of gates added.\n    dimension (int): The dimension of the quantum system (default is 2 for qubits).</p>\n"}, {"fullname": "sdim.gatedata.GateData.__init__", "modulename": "sdim.gatedata", "qualname": "GateData.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span></span>)</span>"}, {"fullname": "sdim.gatedata.GateData.gateMap", "modulename": "sdim.gatedata", "qualname": "GateData.gateMap", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "sdim.gatedata.GateData.aliasMap", "modulename": "sdim.gatedata", "qualname": "GateData.aliasMap", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "sdim.gatedata.GateData.num_gates", "modulename": "sdim.gatedata", "qualname": "GateData.num_gates", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "sdim.gatedata.GateData.dimension", "modulename": "sdim.gatedata", "qualname": "GateData.dimension", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "2"}, {"fullname": "sdim.gatedata.GateData.add_gate", "modulename": "sdim.gatedata", "qualname": "GateData.add_gate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">arg_count</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.add_gate_alias", "modulename": "sdim.gatedata", "qualname": "GateData.add_gate_alias", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">list_alias</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.add_gate_data_pauli", "modulename": "sdim.gatedata", "qualname": "GateData.add_gate_data_pauli", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.add_gate_hada", "modulename": "sdim.gatedata", "qualname": "GateData.add_gate_hada", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.add_gate_controlled", "modulename": "sdim.gatedata", "qualname": "GateData.add_gate_controlled", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.add_gate_collapsing", "modulename": "sdim.gatedata", "qualname": "GateData.add_gate_collapsing", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.get_gate_id", "modulename": "sdim.gatedata", "qualname": "GateData.get_gate_id", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">gate_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.get_gate_name", "modulename": "sdim.gatedata", "qualname": "GateData.get_gate_name", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">gate_id</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.gatedata.GateData.get_gate_matrix", "modulename": "sdim.gatedata", "qualname": "GateData.get_gate_matrix", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">gate_id</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.program", "modulename": "sdim.program", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.program.GATE_FUNCTIONS", "modulename": "sdim.program", "qualname": "GATE_FUNCTIONS", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict[int, typing.Callable]", "default_value": "{0: &lt;function apply_I&gt;, 1: &lt;function apply_X&gt;, 2: &lt;function apply_X_inv&gt;, 3: &lt;function apply_Z&gt;, 4: &lt;function apply_Z_inv&gt;, 5: &lt;function apply_H&gt;, 6: &lt;function apply_H_inv&gt;, 7: &lt;function apply_P&gt;, 8: &lt;function apply_P_inv&gt;, 9: &lt;function apply_CNOT&gt;, 10: &lt;function apply_CNOT_inv&gt;, 11: &lt;function apply_CZ&gt;, 12: &lt;function apply_CZ_inv&gt;, 13: &lt;function apply_SWAP&gt;, 14: &lt;function apply_measure&gt;, 15: &lt;function apply_measure_x&gt;}"}, {"fullname": "sdim.program.Program", "modulename": "sdim.program", "qualname": "Program", "kind": "class", "doc": "<p>Represents a quantum program with a circuit and stabilizer tableau.</p>\n\n<p>This class handles the initialization and simulation of a quantum program,\nincluding applying gates and managing measurement results.</p>\n\n<p>Attributes:\n    stabilizer_tableau: The current state of the quantum system.\n    circuit: A Circuit object representing the quantum circuit.\n    measurement_results: A list of MeasurementResult objects.</p>\n\n<p>Args:\n    circuit (Circuit): A Circuit object representing the quantum circuit.\n    tableau (Optional[Tableau]): An optional stabilizer tableau. If not provided,\n        the default is the all zero computational basis.</p>\n"}, {"fullname": "sdim.program.Program.__init__", "modulename": "sdim.program", "qualname": "Program.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">circuit</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">Circuit</span>, </span><span class=\"param\"><span class=\"n\">tableau</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "sdim.program.Program.circuits", "modulename": "sdim.program", "qualname": "Program.circuits", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.program.Program.measurement_results", "modulename": "sdim.program", "qualname": "Program.measurement_results", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.program.Program.simulate", "modulename": "sdim.program", "qualname": "Program.simulate", "kind": "function", "doc": "<p>Runs the circuit and applies the gates to the stabilizer tableau.</p>\n\n<p>Args:\n    show_measurement (bool): Whether to print the measurement results.\n    verbose (bool): Whether to print the stabilizer tableau at each time step.\n    show_gate (bool): Whether to print the gate name at each time step.\n    exact (bool): Whether to use the Diophantine solver instead of column reduction.\n        Much slower but fails less often.</p>\n\n<p>Returns:\n    list[MeasurementResult]: A list of MeasurementResult objects representing\n    the measurement results. Returns an empty list if no measurements are present.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">show_measurement</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_gate</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">exact</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">MeasurementResult</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.program.Program.append_circuit", "modulename": "sdim.program", "qualname": "Program.append_circuit", "kind": "function", "doc": "<p>Appends a circuit to the existing Program.</p>\n\n<p>Args:\n    circuit (Circuit): The Circuit object to append.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">circuit</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">Circuit</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.program.Program.apply_gate", "modulename": "sdim.program", "qualname": "Program.apply_gate", "kind": "function", "doc": "<p>Applies a gate to the stabilizer tableau.</p>\n\n<p>Args:\n    instruc (CircuitInstruction): A CircuitInstruction object from a Circuit's operation list.\n    exact (bool): Whether to use exact computation methods.</p>\n\n<p>Returns:\n    MeasurementResult: A MeasurementResult object if the gate is a measurement gate, otherwise None.</p>\n\n<p>Raises:\n    ValueError: If an invalid gate value is provided.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">instruc</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">CircuitInstruction</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">MeasurementResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.program.Program.print_measurements", "modulename": "sdim.program", "qualname": "Program.print_measurements", "kind": "function", "doc": "<p>Prints the measurement results.</p>\n\n<p>This method iterates through the stored measurement results and prints each one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.random_circuit", "modulename": "sdim.random_circuit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.random_circuit.generate_random_circuit", "modulename": "sdim.random_circuit", "qualname": "generate_random_circuit", "kind": "function", "doc": "<p>Generates a random quantum circuit with specified gate type percentages.</p>\n\n<p>This function creates a circuit with a given distribution of gate types. \nBy default, it generates no measurement gates unless specified.</p>\n\n<p>Args:\n    c_percentage: Percentage of CNOT gates.\n    h_percentage: Percentage of Hadamard gates.\n    p_percentage: Percentage of Phase gates.\n    m_percentage: Percentage of Measurement gates.\n    num_qudits: Number of qudits in the circuit.\n    num_gates: Total number of gates in the circuit.\n    dimension: Dimension of the qudits.\n    measurement_rounds: Number of measurement rounds. Defaults to 0.\n    seed: Random seed for reproducibility. Defaults to None.</p>\n\n<p>Returns:\n    Circuit: A randomly generated Circuit object.</p>\n\n<p>Raises:\n    ValueError: If the sum of all percentages is not equal to 100.</p>\n\n<p>Note:\n    The percentages should sum to 100 (not 1).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">c_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">h_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">m_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">num_qudits</span>,</span><span class=\"param\">\t<span class=\"n\">num_gates</span>,</span><span class=\"param\">\t<span class=\"n\">dimension</span>,</span><span class=\"param\">\t<span class=\"n\">measurement_rounds</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.random_circuit.generate_and_write_random_circuit", "modulename": "sdim.random_circuit", "qualname": "generate_and_write_random_circuit", "kind": "function", "doc": "<p>Generates a random quantum circuit and writes it to a file.</p>\n\n<p>This function creates a random circuit with specified gate type percentages\nand writes the resulting circuit to a file.</p>\n\n<p>Args:\n    c_percentage: Percentage of CNOT gates.\n    h_percentage: Percentage of Hadamard gates.\n    p_percentage: Percentage of Phase gates.\n    m_percentage: Percentage of Measurement gates.\n    num_qudits: Number of qudits in the circuit.\n    num_gates: Total number of gates in the circuit.\n    dimension: Dimension of the qudits.\n    measurement_rounds: Number of measurement rounds. Defaults to 0.\n    output_file: Name of the output file. Defaults to \"random_circuit.chp\".\n    seed: Random seed for reproducibility. Defaults to None.</p>\n\n<p>Returns:\n    Circuit: The randomly generated Circuit object.</p>\n\n<p>Note:\n    The percentages should sum to 100 (not 1).\n    The circuit is written to the specified output file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">c_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">h_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">m_percentage</span>,</span><span class=\"param\">\t<span class=\"n\">num_qudits</span>,</span><span class=\"param\">\t<span class=\"n\">num_gates</span>,</span><span class=\"param\">\t<span class=\"n\">dimension</span>,</span><span class=\"param\">\t<span class=\"n\">measurement_rounds</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"s1\">&#39;random_circuit.chp&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau", "modulename": "sdim.tableau", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.tableau.dataclasses", "modulename": "sdim.tableau.dataclasses", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.tableau.dataclasses.MeasurementResult", "modulename": "sdim.tableau.dataclasses", "qualname": "MeasurementResult", "kind": "class", "doc": "<p>Represents the result of a qudit measurement in a quantum circuit.</p>\n\n<p>Attributes:\n    qudit_index (int): The index of the measured qudit.\n    deterministic (bool): Whether the measurement result was deterministic.\n    measurement_value (int): The measured value of the qudit.</p>\n"}, {"fullname": "sdim.tableau.dataclasses.MeasurementResult.__init__", "modulename": "sdim.tableau.dataclasses", "qualname": "MeasurementResult.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">deterministic</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>, </span><span class=\"param\"><span class=\"n\">measurement_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "sdim.tableau.dataclasses.MeasurementResult.qudit_index", "modulename": "sdim.tableau.dataclasses", "qualname": "MeasurementResult.qudit_index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "sdim.tableau.dataclasses.MeasurementResult.deterministic", "modulename": "sdim.tableau.dataclasses", "qualname": "MeasurementResult.deterministic", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "sdim.tableau.dataclasses.MeasurementResult.measurement_value", "modulename": "sdim.tableau.dataclasses", "qualname": "MeasurementResult.measurement_value", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "sdim.tableau.dataclasses.Tableau", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau", "kind": "class", "doc": "<p>Represents a stabilizer tableau for a quantum circuit simulation.</p>\n\n<p>This class encapsulates the phase vector, Z block, and X block that \ndescribe the state of a quantum system in the stabilizer formalism.</p>\n\n<p>Attributes:\n    num_qudits (int): The number of qudits in the system.\n    dimension (int): The dimension of each qudit (default is 2 for qubits).\n    phase_vector (np.ndarray): The phase vector of the tableau.\n    z_block (np.ndarray): The Z block of the tableau.\n    x_block (np.ndarray): The X block of the tableau.</p>\n"}, {"fullname": "sdim.tableau.dataclasses.Tableau.__init__", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_qudits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">dimension</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">phase_vector</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">z_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">x_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "sdim.tableau.dataclasses.Tableau.num_qudits", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.num_qudits", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "sdim.tableau.dataclasses.Tableau.dimension", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.dimension", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "2"}, {"fullname": "sdim.tableau.dataclasses.Tableau.phase_vector", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.phase_vector", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[numpy.ndarray]", "default_value": "None"}, {"fullname": "sdim.tableau.dataclasses.Tableau.z_block", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.z_block", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[numpy.ndarray]", "default_value": "None"}, {"fullname": "sdim.tableau.dataclasses.Tableau.x_block", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.x_block", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[numpy.ndarray]", "default_value": "None"}, {"fullname": "sdim.tableau.dataclasses.Tableau.coprime_order", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.coprime_order", "kind": "variable", "doc": "<p>Returns a set of integers coprime to the order.</p>\n\n<p>Returns:\n    set: Integers coprime to the order.</p>\n", "annotation": ": set"}, {"fullname": "sdim.tableau.dataclasses.Tableau.coprime_dimension", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.coprime_dimension", "kind": "variable", "doc": "<p>Returns a set of integers coprime to the dimension.</p>\n\n<p>Returns:\n    set: Integers coprime to the dimension.</p>\n", "annotation": ": set"}, {"fullname": "sdim.tableau.dataclasses.Tableau.prime", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.prime", "kind": "variable", "doc": "<p>Checks if the dimension is prime.</p>\n\n<p>Returns:\n    bool: True if the dimension is prime, False otherwise.</p>\n", "annotation": ": bool"}, {"fullname": "sdim.tableau.dataclasses.Tableau.even", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.even", "kind": "variable", "doc": "<p>Checks if the dimension is even.</p>\n\n<p>Returns:\n    bool: True if the dimension is even, False otherwise.</p>\n", "annotation": ": bool"}, {"fullname": "sdim.tableau.dataclasses.Tableau.order", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.order", "kind": "variable", "doc": "<p>Calculates the order of the Weyl-Heisenberg group.</p>\n\n<p>Returns:\n    int: The order of the Weyl-Heisenberg group.</p>\n", "annotation": ": int"}, {"fullname": "sdim.tableau.dataclasses.Tableau.phase_order", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.phase_order", "kind": "variable", "doc": "<p>Calculates the order of the phase.</p>\n\n<p>Returns:\n    int: The order of the phase.</p>\n", "annotation": ": int"}, {"fullname": "sdim.tableau.dataclasses.Tableau.pauli_size", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.pauli_size", "kind": "variable", "doc": "<p>Calculates the size of the Pauli group.</p>\n\n<p>Returns:\n    int: The size of the Pauli group.</p>\n", "annotation": ": int"}, {"fullname": "sdim.tableau.dataclasses.Tableau.stab_tableau", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.stab_tableau", "kind": "variable", "doc": "<p>Returns the full stabilizer tableau.</p>\n\n<p>Returns:\n    np.ndarray: The stabilizer tableau as a vertically stacked matrix.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "sdim.tableau.dataclasses.Tableau.print_phase_vector", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.print_phase_vector", "kind": "function", "doc": "<p>Prints the phase vector of the tableau.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.dataclasses.Tableau.print_z_block", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.print_z_block", "kind": "function", "doc": "<p>Prints the Z block of the tableau.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.dataclasses.Tableau.print_x_block", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.print_x_block", "kind": "function", "doc": "<p>Prints the X block of the tableau.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.dataclasses.Tableau.print_tableau", "modulename": "sdim.tableau.dataclasses", "qualname": "Tableau.print_tableau", "kind": "function", "doc": "<p>Prints the full tableau, including phase vector, Z block, and X block.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite", "modulename": "sdim.tableau.tableau_composite", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau", "kind": "class", "doc": "<p></p>\n", "bases": "sdim.tableau.dataclasses.Tableau"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.__init__", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_qudits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">dimension</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">phase_vector</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">z_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">x_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">exact</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.exact", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.exact", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.symplectic_product", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.symplectic_product", "kind": "function", "doc": "<p>Compute the symplectic product of two generators.</p>\n\n<p>Args:\n    index1 (int): Index of the first generator.\n    index2 (int): Index of the second generator.</p>\n\n<p>Returns:\n    int: The symplectic product.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">index2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.append", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.append", "kind": "function", "doc": "<p>Append a Pauli vector to the tableau.</p>\n\n<p>Args:\n    pauli_vector (np.ndarray): The Pauli vector to append.</p>\n\n<p>Raises:\n    ValueError: If the Pauli vector dimensions do not match.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pauli_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.update", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.update", "kind": "function", "doc": "<p>Update a generator in the tableau.</p>\n\n<p>Args:\n    pauli_vector (np.ndarray): The new Pauli vector.\n    index (int): The index of the generator to update.</p>\n\n<p>Raises:\n    ValueError: If the Pauli vector dimensions do not match or if the index is invalid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pauli_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.add_generators", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.add_generators", "kind": "function", "doc": "<p>Add the generators at column index2 to the generators at column index1.</p>\n\n<p>Args:\n    index1 (int): Index of the first generator.\n    index2 (int): Index of the second generator.\n    scalar (int, optional): Scalar multiplier. Defaults to 1.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">index2</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">scalar</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.multiply_generator", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.multiply_generator", "kind": "function", "doc": "<p>Multiply the generators at column index by a scalar.</p>\n\n<p>Args:\n    index (int): Index of the generator to multiply.\n    scalar (int): Scalar to multiply by.\n    allow_non_coprime (bool, optional): Allow non-coprime scalars. Defaults to False.</p>\n\n<p>Raises:\n    ValueError: If the scalar is not coprime with the order and allow_non_coprime is False.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">scalar</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">allow_non_coprime</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.swap_generators", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.swap_generators", "kind": "function", "doc": "<p>Swap generators at index1 to index2.</p>\n\n<p>Args:\n    index1 (int): Index of the first generator.\n    index2 (int): Index of the second generator.</p>\n\n<p>Raises:\n    ValueError: If the indices are invalid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index1</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">index2</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.column_reduction", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.column_reduction", "kind": "function", "doc": "<p>Perform column reduction on the tableau matrix.</p>\n\n<p>Args:\n    tableau_matrix (np.ndarray): The tableau matrix.\n    weyl_vector (np.ndarray): The Weyl vector.\n    s (int): The s value.</p>\n\n<p>Returns:\n    Optional[int]: The result of the column reduction, or None if not found.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tableau_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weyl_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.t_diophantine", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.t_diophantine", "kind": "function", "doc": "<p>Solve whether a tableau contains the weyl vector with a given phase value t is in the column span by solving Ax=b.\nThe modulo constraints can be represented as a linear system of Diophantine equations.</p>\n\n<p>Args:\n    tableau_matrix (np.ndarray): The tableau matrix.\n    weyl_vector (np.ndarray): The Weyl vector.\n    qudit_index (int): Index of the qudit.\n    s (int): The s value.</p>\n\n<p>Returns:\n    Optional[int]: The solution t, or None if not found.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tableau_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weyl_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.measure_z", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.measure_z", "kind": "function", "doc": "<p>Perform a Z measurement on a qudit.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit to measure.</p>\n\n<p>Returns:\n    Optional[MeasurementResult]: The result of the measurement, or None if not applicable.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">MeasurementResult</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.multiply", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.multiply", "kind": "function", "doc": "<p>Apply multiplication gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit.\n    scalar (int): Scalar value to multiply by.</p>\n\n<p>Raises:\n    ValueError: If the scalar is not coprime with the order.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">scalar</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.hadamard", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.hadamard", "kind": "function", "doc": "<p>Apply generalized Hadamard gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.hadamard_inv", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.hadamard_inv", "kind": "function", "doc": "<p>Apply inverse generalized Hadamard gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.phase", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.phase", "kind": "function", "doc": "<p>Apply phase gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit to apply the phase gate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.phase_inv", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.phase_inv", "kind": "function", "doc": "<p>Apply inverse phase gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit to apply the inverse phase gate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.cnot", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.cnot", "kind": "function", "doc": "<p>Apply CNOT gate to control and target qudits.</p>\n\n<p>Args:\n    control_index (int): Index of the control qudit.\n    target_index (int): Index of the target qudit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">control_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">target_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.cnot_inv", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.cnot_inv", "kind": "function", "doc": "<p>Apply inverse CNOT gate to control and target qudits.</p>\n\n<p>Args:\n    control_index (int): Index of the control qudit.\n    target_index (int): Index of the target qudit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">control_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">target_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.x", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.x", "kind": "function", "doc": "<p>Apply Pauli X gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit to apply the Pauli X gate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.x_inv", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.x_inv", "kind": "function", "doc": "<p>Apply Pauli X inverse gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit to apply the inverse Pauli X gate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.z", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.z", "kind": "function", "doc": "<p>Apply Pauli Z gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit to apply the Pauli Z gate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_composite.WeylTableau.z_inv", "modulename": "sdim.tableau.tableau_composite", "qualname": "WeylTableau.z_inv", "kind": "function", "doc": "<p>Apply Pauli Z inverse gate to qudit at index.</p>\n\n<p>Args:\n    qudit_index (int): Index of the qudit to apply the inverse Pauli Z gate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates", "modulename": "sdim.tableau.tableau_gates", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.tableau.tableau_gates.apply_I", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_I", "kind": "function", "doc": "<p>Apply identity gate (do nothing).</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_X", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_X", "kind": "function", "doc": "<p>Apply Pauli X gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_X_inv", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_X_inv", "kind": "function", "doc": "<p>Apply Pauli X inverse gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_Z", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_Z", "kind": "function", "doc": "<p>Apply Pauli Z gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_Z_inv", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_Z_inv", "kind": "function", "doc": "<p>Apply Pauli Z inverse gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_H", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_H", "kind": "function", "doc": "<p>Apply Hadamard gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_H_inv", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_H_inv", "kind": "function", "doc": "<p>Apply Hadamard inverse gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_P", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_P", "kind": "function", "doc": "<p>Apply Phase gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_P_inv", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_P_inv", "kind": "function", "doc": "<p>Apply Phase inverse gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to apply the gate to.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_CNOT", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_CNOT", "kind": "function", "doc": "<p>Apply CNOT gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    control (int): The index of the control qudit.\n    target (int): The index of the target qudit.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>,</span><span class=\"param\">\t<span class=\"n\">control</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_CNOT_inv", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_CNOT_inv", "kind": "function", "doc": "<p>Apply CNOT inverse gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    control (int): The index of the control qudit.\n    target (int): The index of the target qudit.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>,</span><span class=\"param\">\t<span class=\"n\">control</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_CZ", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_CZ", "kind": "function", "doc": "<p>Apply CZ gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    control (int): The index of the control qudit.\n    target (int): The index of the target qudit.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>,</span><span class=\"param\">\t<span class=\"n\">control</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_CZ_inv", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_CZ_inv", "kind": "function", "doc": "<p>Apply CZ inverse gate.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    control (int): The index of the control qudit.\n    target (int): The index of the target qudit.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>,</span><span class=\"param\">\t<span class=\"n\">control</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_measure", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_measure", "kind": "function", "doc": "<p>Apply measurement.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to measure.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    Optional[MeasurementResult]: The result of the measurement, if applicable.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>,</span><span class=\"param\">\t<span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">MeasurementResult</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_measure_x", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_measure_x", "kind": "function", "doc": "<p>Apply X-basis measurement.</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the qudit to measure.\n    _ : Unused target index.</p>\n\n<p>Returns:\n    Optional[MeasurementResult]: The result of the measurement, if applicable.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>,</span><span class=\"param\">\t<span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">_</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">MeasurementResult</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_gates.apply_SWAP", "modulename": "sdim.tableau.tableau_gates", "qualname": "apply_SWAP", "kind": "function", "doc": "<p>Apply SWAP gate.</p>\n\n<p>Taken from Beaudrap Lemma 6 (eq 19)</p>\n\n<p>Args:\n    tableau (Tableau): The quantum tableau.\n    qudit_index (int): The index of the first qudit to swap.\n    target_index (int): The index of the second qudit to swap.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tableau</span><span class=\"p\">:</span> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Tableau</span>,</span><span class=\"param\">\t<span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">target_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime", "modulename": "sdim.tableau.tableau_prime", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau", "kind": "class", "doc": "<p>Represents an extended stabilizer tableau for quantum circuit simulation.</p>\n\n<p>This class extends the Tableau class by including destabilizer information,\nwhich allows for more efficient simulation of certain quantum operations.</p>\n\n<p>This follows as a generalization to prime dimensions from\n\"Improved Simulation of Stabilizer Circuits\" by Aaronson and Gottesman.</p>\n\n<p>Attributes:\n    destab_phase_vector (np.ndarray): The phase vector for destabilizers.\n    destab_z_block (np.ndarray): The Z block for destabilizers.\n    destab_x_block (np.ndarray): The X block for destabilizers.</p>\n", "bases": "sdim.tableau.dataclasses.Tableau"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.__init__", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_qudits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">dimension</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">phase_vector</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">z_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">x_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">destab_phase_vector</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">destab_z_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">destab_x_block</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.destab_phase_vector", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.destab_phase_vector", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[numpy.ndarray]", "default_value": "None"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.destab_z_block", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.destab_z_block", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[numpy.ndarray]", "default_value": "None"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.destab_x_block", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.destab_x_block", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[numpy.ndarray]", "default_value": "None"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.print_destab_phase_vector", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.print_destab_phase_vector", "kind": "function", "doc": "<p>Prints the phase vector of the destabilizer tableau.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.print_destab_z_block", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.print_destab_z_block", "kind": "function", "doc": "<p>Prints the Z block of the destabilizer tableau.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.print_destab_x_block", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.print_destab_x_block", "kind": "function", "doc": "<p>Prints the X block of the destabilizer tableau.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.print_tableau", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.print_tableau", "kind": "function", "doc": "<p>Prints the full tableau, including phase vector, Z block, X block,\nand the destabilizer components.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.destab_tableau", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.destab_tableau", "kind": "variable", "doc": "<p>Returns the destabilizer tableau as a vertically stacked matrix.</p>\n\n<p>Returns:\n    np.ndarray: The destabilizer tableau.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.tableau", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.tableau", "kind": "variable", "doc": "<p>Returns the full tableau with stabilizers and destabilizers.</p>\n\n<p>Returns:\n    np.ndarray: The full tableau.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.hadamard", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.hadamard", "kind": "function", "doc": "<p>Applies the Hadamard gate to the qudit at the specified index.</p>\n\n<p>The Hadamard gate performs the following transformations:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>X</td>\n  <td>Z</td>\n</tr>\n<tr>\n  <td>Z</td>\n  <td>X^-1</td>\n</tr>\n</tbody>\n</table>\n\n<p>The phase transformation is given by:</p>\n\n<p>$$ HXZ\\Psi = ZX^{-1}\\Psi = \\omega^{d-1} XZ\\Psi $$</p>\n\n<p>where $\\omega = e^{2\\pi i / d}$ and $d$ is the qudit dimension.</p>\n\n<p>Args:\n    qudit_index (int): The index of the qudit to apply the Hadamard gate to.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.hadamard_inv", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.hadamard_inv", "kind": "function", "doc": "<p>Applies the inverse Hadamard gate to the qudit at the specified index.</p>\n\n<p>The inverse Hadamard gate transformations depend on whether the qudit dimension is odd or even:</p>\n\n<p>For odd dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>X</td>\n  <td>Z^-1</td>\n</tr>\n<tr>\n  <td>Z</td>\n  <td>X</td>\n</tr>\n</tbody>\n</table>\n\n<p>For even dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>X</td>\n  <td>Z^-1</td>\n</tr>\n<tr>\n  <td>Z</td>\n  <td>X</td>\n</tr>\n</tbody>\n</table>\n\n<p>Args:\n    qudit_index (int): The index of the qudit to apply the inverse Hadamard gate to.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.phase", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.phase", "kind": "function", "doc": "<p>Applies the Phase gate to the qudit at the specified index.</p>\n\n<p>The Phase gate transformations depend on whether the qudit dimension is odd or even:</p>\n\n<p>For odd dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>X</td>\n  <td>XZ</td>\n</tr>\n<tr>\n  <td>Z</td>\n  <td>Z</td>\n</tr>\n</tbody>\n</table>\n\n<p>For even dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>XZ</td>\n  <td>$\\omega^{1/2}$ XZ</td>\n</tr>\n<tr>\n  <td>Z</td>\n  <td>Z</td>\n</tr>\n</tbody>\n</table>\n\n<p>Where $\\omega = e^{2\\pi i / d}$ and $d$ is the qudit dimension.</p>\n\n<p>The phase accumulation for even dimensions is given by:</p>\n\n<p>$$      ext{phase} += x^2 $$</p>\n\n<p>where $x$ is the X-power in the Pauli string.</p>\n\n<p>Args:\n    qudit_index (int): The index of the qudit to apply the Phase gate to.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.phase_inv", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.phase_inv", "kind": "function", "doc": "<p>Applies the inverse Phase gate to the qudit at the specified index.</p>\n\n<p>The inverse Phase gate transformations depend on whether the qudit dimension is odd or even:</p>\n\n<p>For odd dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>X</td>\n  <td>XZ^-1</td>\n</tr>\n<tr>\n  <td>Z</td>\n  <td>Z</td>\n</tr>\n</tbody>\n</table>\n\n<p>For even dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>$\\omega^{1/2}$ XZ</td>\n  <td>XZ</td>\n</tr>\n<tr>\n  <td>Z</td>\n  <td>Z</td>\n</tr>\n</tbody>\n</table>\n\n<p>Args:\n    qudit_index (int): The index of the qudit to apply the inverse Phase gate to.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.cnot", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.cnot", "kind": "function", "doc": "<p>Applies the CNOT gate with the specified control and target qudits.</p>\n\n<p>The CNOT gate performs the following transformations:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>XI</td>\n  <td>XX</td>\n</tr>\n<tr>\n  <td>IX</td>\n  <td>IX</td>\n</tr>\n<tr>\n  <td>ZI</td>\n  <td>ZI</td>\n</tr>\n<tr>\n  <td>IZ</td>\n  <td>Z^-1Z</td>\n</tr>\n</tbody>\n</table>\n\n<p>Args:\n    control (int): The index of the control qudit.\n    target (int): The index of the target qudit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">control</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.cnot_inv", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.cnot_inv", "kind": "function", "doc": "<p>Applies the inverse CNOT gate with the specified control and target qudits.</p>\n\n<p>The inverse CNOT gate transformations depend on whether the qudit dimension is odd or even:</p>\n\n<p>For odd dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>XX</td>\n  <td>XI</td>\n</tr>\n<tr>\n  <td>IX</td>\n  <td>IX</td>\n</tr>\n<tr>\n  <td>ZI</td>\n  <td>ZI</td>\n</tr>\n<tr>\n  <td>Z^-1Z</td>\n  <td>IZ</td>\n</tr>\n</tbody>\n</table>\n\n<p>For even dimensions:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Input</th>\n  <th>Output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>XX</td>\n  <td>XI</td>\n</tr>\n<tr>\n  <td>IX</td>\n  <td>IX</td>\n</tr>\n<tr>\n  <td>ZI</td>\n  <td>ZI</td>\n</tr>\n<tr>\n  <td>Z^-1Z</td>\n  <td>IZ</td>\n</tr>\n</tbody>\n</table>\n\n<p>Args:\n    control (int): The index of the control qudit.\n    target (int): The index of the target qudit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">control</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.measure", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.measure", "kind": "function", "doc": "<p>Measures the qudit at the specified index in the Z basis.</p>\n\n<p>Args:\n    qudit_index (int): The index of the qudit to measure.</p>\n\n<p>Returns:\n    MeasurementResult: The result of the measurement, including whether it was\n                       deterministic and the measured value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qudit_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sdim</span><span class=\"o\">.</span><span class=\"n\">tableau</span><span class=\"o\">.</span><span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">MeasurementResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.tableau.tableau_prime.ExtendedTableau.exponentiate", "modulename": "sdim.tableau.tableau_prime", "qualname": "ExtendedTableau.exponentiate", "kind": "function", "doc": "<p>Exponentiates a Pauli string by the given exponent.</p>\n\n<p>This operation performs the following transformation:\n(X^a Z^b)^n = w^(ab*n(n-1)/2) X^(na) Z^(nb)</p>\n\n<p>Args:\n    col (int): The column index of the Pauli string to exponentiate.\n    exponent (int): The exponent to raise the Pauli string to.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">exponent</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary", "modulename": "sdim.unitary", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.generate_tau", "modulename": "sdim.unitary", "qualname": "generate_tau", "kind": "function", "doc": "<p>Generates the tau value for dimension d. Given by Beaudrap.\nArgs:\n    d: The dimension of the tau value\nReturns:\n    The tau value for dimension d</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.generate_identity_matrix", "modulename": "sdim.unitary", "qualname": "generate_identity_matrix", "kind": "function", "doc": "<p>Generates the identity matrix for dimension d.\nArgs:\n    d: The dimension of the identity matrix\nReturns:\n    The identity matrix of dimension d</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.generate_x_matrix", "modulename": "sdim.unitary", "qualname": "generate_x_matrix", "kind": "function", "doc": "<p>Generates the generalized Pauli-X matrix for dimension d.\nArgs:\n    d: The dimension of the X matrix\nReturns:\n    The X matrix of dimension d</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.generate_z_matrix", "modulename": "sdim.unitary", "qualname": "generate_z_matrix", "kind": "function", "doc": "<p>Generates the generalized Pauli-Z matrix for dimension d.\nArgs:\n    d: The dimension of the Z matrix\nReturns:\n    The Z matrix of dimension d</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.generate_h_matrix", "modulename": "sdim.unitary", "qualname": "generate_h_matrix", "kind": "function", "doc": "<p>Generates the generalized Hadamard matrix for dimension d.\nArgs:\n    d: The dimension of the Hadamard matrix\nReturns:\n    The Hadamard matrix of dimension d</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.generate_m_matrix", "modulename": "sdim.unitary", "qualname": "generate_m_matrix", "kind": "function", "doc": "<p>Generates the multiplicative gate based on some integer a coprime to d and the dimension d.\nArgs:\n    d: The dimension of the multiplicative gate\n    a: The integer coprime to d\nReturns:\n    The multiplicative gate of dimension d and integer a</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.generate_p_matrix", "modulename": "sdim.unitary", "qualname": "generate_p_matrix", "kind": "function", "doc": "<p>Generates the phase shift matrix for dimension d. An important distinction is \nmade between prime and non-prime dimensions. For prime dimensions, the function follows \"An Ideal Characterization of the Clifford Operators\" (Farinholt).\nFor non-prime dimensions, the function follows \"A linearized stabilizer formalism for systems of finite dimension\" (Beaudrap).\nArgs:\n    d: The dimension of the phase shift matrix\nReturns:\n    The phase shift matrix of dimension d</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.generate_cnot_matrix", "modulename": "sdim.unitary", "qualname": "generate_cnot_matrix", "kind": "function", "doc": "<p>Geneates the CNOT (SUM) gate for dimension d. Does not contain the phase correction present in the d even case as present in Farinholt.\nArgs:\n    d: The dimension of the CNOT gate\nReturns:\n    The CNOT gate of dimension d</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedHadamardGate", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGate", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedHadamardGate.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGate.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedHadamardGate.d", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGate.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedHadamardGate.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGate.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedHadamardGateInverse", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGateInverse", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedHadamardGateInverse.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGateInverse.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedHadamardGateInverse.d", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGateInverse.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedHadamardGateInverse.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedHadamardGateInverse.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGate", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGate", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGate.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGate.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGate.d", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGate.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGate.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGate.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGateInverse", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGateInverse", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGateInverse.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGateInverse.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGateInverse.d", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGateInverse.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedPhaseShiftGateInverse.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedPhaseShiftGateInverse.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedXPauliGate", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGate", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedXPauliGate.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGate.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedXPauliGate.d", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGate.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedXPauliGate.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGate.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedXPauliGateInverse", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGateInverse", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedXPauliGateInverse.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGateInverse.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedXPauliGateInverse.d", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGateInverse.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedXPauliGateInverse.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedXPauliGateInverse.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedZPauliGate", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGate", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedZPauliGate.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGate.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedZPauliGate.d", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGate.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedZPauliGate.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGate.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedZPauliGateInverse", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGateInverse", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedZPauliGateInverse.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGateInverse.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedZPauliGateInverse.d", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGateInverse.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedZPauliGateInverse.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedZPauliGateInverse.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedCNOTGate", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGate", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedCNOTGate.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGate.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedCNOTGate.d", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGate.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedCNOTGate.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGate.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.GeneralizedCNOTGateInverse", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGateInverse", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.GeneralizedCNOTGateInverse.__init__", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGateInverse.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.GeneralizedCNOTGateInverse.d", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGateInverse.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.GeneralizedCNOTGateInverse.num_qubits", "modulename": "sdim.unitary", "qualname": "GeneralizedCNOTGateInverse.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sdim.unitary.IdentityGate", "modulename": "sdim.unitary", "qualname": "IdentityGate", "kind": "class", "doc": "<p>An operation type that can be applied to a collection of qubits.</p>\n\n<p>Gates can be applied to qubits by calling their on() method with\nthe qubits to be applied to supplied, or, alternatively, by simply\ncalling the gate on the qubits.  In other words calling MyGate.on(q1, q2)\nto create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</p>\n\n<p>Gates operate on a certain number of qubits. All implementations of gate\nmust implement the <code>num_qubits</code> method declaring how many qubits they\nact on.</p>\n\n<p>Linear combinations of gates can be created by adding gates together and\nmultiplying them by scalars.</p>\n", "bases": "cirq.ops.raw_types.Gate"}, {"fullname": "sdim.unitary.IdentityGate.__init__", "modulename": "sdim.unitary", "qualname": "IdentityGate.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span></span>)</span>"}, {"fullname": "sdim.unitary.IdentityGate.d", "modulename": "sdim.unitary", "qualname": "IdentityGate.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sdim.unitary.IdentityGate.num_qubits", "modulename": "sdim.unitary", "qualname": "IdentityGate.num_qubits", "kind": "function", "doc": "<p>The number of qubits this gate acts on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();